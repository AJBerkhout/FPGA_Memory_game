|memory_game
clk_50 => clk_divider:clock_divider_inst.CLK_IN
btn_one => edge_detect:edge_detect_inst1.level
btn_two => edge_detect:edge_detect_inst2.level
btn_three => edge_detect:edge_detect_inst3.level
btn_four => edge_detect:edge_detect_inst4.level
power_switch => edge_detect:edge_detect_inst1.reset
power_switch => edge_detect:edge_detect_inst2.reset
power_switch => edge_detect:edge_detect_inst3.reset
power_switch => edge_detect:edge_detect_inst4.reset
power_switch => LFSR:lsfr_inst.reset
power_switch => input_handler:input_handler_inst.reset
leds[0] << LFSR:lsfr_inst.z[0]
leds[1] << LFSR:lsfr_inst.z[1]
leds[2] << LFSR:lsfr_inst.z[2]
leds[3] << LFSR:lsfr_inst.z[3]
input_val << input_handler:input_handler_inst.success


|memory_game|clk_divider:clock_divider_inst
CLK_IN => D.CLK
CLK_IN => count3[0].CLK
CLK_IN => count3[1].CLK
CLK_IN => count3[2].CLK
CLK_IN => count3[3].CLK
CLK_IN => count3[4].CLK
CLK_IN => count3[5].CLK
CLK_IN => count3[6].CLK
CLK_IN => count3[7].CLK
CLK_IN => count3[8].CLK
CLK_IN => count3[9].CLK
CLK_IN => count2[0].CLK
CLK_IN => count2[1].CLK
CLK_IN => count2[2].CLK
CLK_IN => count2[3].CLK
CLK_IN => count2[4].CLK
CLK_IN => count2[5].CLK
CLK_IN => count2[6].CLK
CLK_IN => count2[7].CLK
CLK_IN => count2[8].CLK
CLK_IN => count2[9].CLK
CLK_IN => count1[0].CLK
CLK_IN => count1[1].CLK
CLK_IN => count1[2].CLK
CLK_IN => count1[3].CLK
CLK_IN => count1[4].CLK
CLK_IN => count1[5].CLK
CLK_IN => count1[6].CLK
CLK_IN => count1[7].CLK
CLK_IN => count1[8].CLK
CLK_IN => count1[9].CLK
CLK_IN => count0[0].CLK
CLK_IN => count0[1].CLK
CLK_IN => count0[2].CLK
CLK_IN => count0[3].CLK
CLK_IN => count0[4].CLK
CLK_IN => count0[5].CLK
CLK_IN => count0[6].CLK
CLK_IN => count0[7].CLK
CLK_IN => count0[8].CLK
CLK_IN => count0[9].CLK
CLK_OUT <= D.DB_MAX_OUTPUT_PORT_TYPE


|memory_game|edge_detect:edge_detect_inst1
clk => state_current.CLK
reset => state_current.ACLR
level => state_next.OUTPUTSELECT
level => tick.DATAB
level => state_next.OUTPUTSELECT
tick <= tick.DB_MAX_OUTPUT_PORT_TYPE


|memory_game|edge_detect:edge_detect_inst2
clk => state_current.CLK
reset => state_current.ACLR
level => state_next.OUTPUTSELECT
level => tick.DATAB
level => state_next.OUTPUTSELECT
tick <= tick.DB_MAX_OUTPUT_PORT_TYPE


|memory_game|edge_detect:edge_detect_inst3
clk => state_current.CLK
reset => state_current.ACLR
level => state_next.OUTPUTSELECT
level => tick.DATAB
level => state_next.OUTPUTSELECT
tick <= tick.DB_MAX_OUTPUT_PORT_TYPE


|memory_game|edge_detect:edge_detect_inst4
clk => state_current.CLK
reset => state_current.ACLR
level => state_next.OUTPUTSELECT
level => tick.DATAB
level => state_next.OUTPUTSELECT
tick <= tick.DB_MAX_OUTPUT_PORT_TYPE


|memory_game|LFSR:lsfr_inst
clk => q[0].CLK
clk => q[1].CLK
clk => q[2].CLK
clk => q[3].CLK
clk => q[4].CLK
clk => q[5].CLK
clk => q[6].CLK
clk => q[7].CLK
gen_next => q[7].ENA
gen_next => q[6].ENA
gen_next => q[5].ENA
gen_next => q[4].ENA
gen_next => q[3].ENA
gen_next => q[2].ENA
gen_next => q[1].ENA
gen_next => q[0].ENA
reset => q[0].PRESET
reset => q[1].ACLR
reset => q[2].ACLR
reset => q[3].ACLR
reset => q[4].ACLR
reset => q[5].ACLR
reset => q[6].ACLR
reset => q[7].ACLR
z[0] <= Mux3.DB_MAX_OUTPUT_PORT_TYPE
z[1] <= Mux2.DB_MAX_OUTPUT_PORT_TYPE
z[2] <= Mux1.DB_MAX_OUTPUT_PORT_TYPE
z[3] <= Mux0.DB_MAX_OUTPUT_PORT_TYPE


|memory_game|input_handler:input_handler_inst
tick1 => Equal1.IN7
tick1 => Equal0.IN3
tick2 => Equal1.IN6
tick2 => Equal0.IN2
tick3 => Equal1.IN5
tick3 => Equal0.IN1
tick4 => Equal1.IN4
tick4 => Equal0.IN0
reset => state_current.ACLR
clk => state_current.CLK
expected_input[0] => Equal1.IN3
expected_input[1] => Equal1.IN2
expected_input[2] => Equal1.IN1
expected_input[3] => Equal1.IN0
done <= internal_done.DB_MAX_OUTPUT_PORT_TYPE
success <= internal_success.DB_MAX_OUTPUT_PORT_TYPE


